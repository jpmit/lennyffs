#! /usr/bin/env python

# len_neighbour
# James Mithen
# Compute the number of nearest neighbours of each particle

import sys
import numpy as np
import readwrite

# assignment dict for BCC and FCC particles: key is number of
# neighbours, value is symbol.  If a particle has a number of
# neighbours that is not a key in this dictionary, it is not written
# to the output file.
PARSYMB = {7  : 'F', # bcc
           8  : 'F', # bcc
           9  : 'F', # bcc
           11 : 'S', # cp
           12 : 'S', # cp
           13 : 'S'  # cp
           }

if len(sys.argv) != 4:
    sys.exit("Syntax len_neighbour infile.xyz outfile")

rcut = float(sys.argv[1])
infile = sys.argv[2]
outfile = sys.argv[3]

positions, symbols = readwrite.rxyz(infile, True)
npar = len(positions)
nneigh = np.zeros(npar, dtype='int')
rcutsq = rcut**2

for i in range(npar):
    for j in range(i + 1, npar):
        # figure out if i and j are neighbours
        sepsq = sum((positions[i] - positions[j])**2)

        if (sepsq < rcutsq):
            nneigh[i] += 1
            nneigh[j] += 1

# store indexes of particles we want (those with the correct number of
# neighbours).
wanted = []
symbs = []
for i in range(npar):
    if nneigh[i] in PARSYMB:
        wanted.append(i)
        symbs.append(PARSYMB[nneigh[i]])

# use awesome numpy array indexing here!
readwrite.wxyz(outfile, positions[wanted], symbs)


    
